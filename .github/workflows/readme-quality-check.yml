name: README Quality Check

on:
  pull_request:
    paths: 
      - 'README*.md'
      - 'Docs/**/*.md'
  push:
    branches: [main, master, develop]
  workflow_dispatch:

jobs:
  readme-quality-check:
    name: Multi-language README Quality Assessment
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests beautifulsoup4 pyyaml
        
    - name: Create quality checker script
      run: |
        cat > readme_checker.py << 'EOF'
        #!/usr/bin/env python3
        # -*- coding: utf-8 -*-
        """
        SuperClaudeå¤šè¯­è¨€READMEè´¨é‡æ£€æŸ¥å™¨
        æ£€æŸ¥ç‰ˆæœ¬åŒæ­¥ã€é“¾æ¥æœ‰æ•ˆæ€§ã€ç»“æ„ä¸€è‡´æ€§
        """
        
        import os
        import re
        import requests
        import json
        from pathlib import Path
        from urllib.parse import urljoin
        
        class READMEQualityChecker:
            def __init__(self):
                self.readme_files = ['README.md', 'README-zh.md', 'README-ja.md']
                self.results = {
                    'structure_consistency': [],
                    'link_validation': [],
                    'translation_sync': [],
                    'overall_score': 0
                }
                
            def check_structure_consistency(self):
                """æ£€æŸ¥ç»“æ„ä¸€è‡´æ€§"""
                print("ğŸ” æ£€æŸ¥ç»“æ„ä¸€è‡´æ€§...")
                
                structures = {}
                for file in self.readme_files:
                    if os.path.exists(file):
                        with open(file, 'r', encoding='utf-8') as f:
                            content = f.read()
                            # æå–æ ‡é¢˜ç»“æ„
                            headers = re.findall(r'^#{1,6}\s+(.+)$', content, re.MULTILINE)
                            structures[file] = len(headers)
                            
                # æ¯”è¾ƒç»“æ„å·®å¼‚
                line_counts = [structures.get(f, 0) for f in self.readme_files if f in structures]
                if line_counts:
                    max_diff = max(line_counts) - min(line_counts)
                    consistency_score = max(0, 100 - (max_diff * 5))
                    
                    self.results['structure_consistency'] = {
                        'score': consistency_score,
                        'details': structures,
                        'status': 'PASS' if consistency_score >= 90 else 'WARN'
                    }
                    
                    print(f"âœ… ç»“æ„ä¸€è‡´æ€§: {consistency_score}/100")
                    for file, count in structures.items():
                        print(f"   {file}: {count} headers")
                        
            def check_link_validation(self):
                """æ£€æŸ¥é“¾æ¥æœ‰æ•ˆæ€§"""
                print("ğŸ”— æ£€æŸ¥é“¾æ¥æœ‰æ•ˆæ€§...")
                
                all_links = {}
                broken_links = []
                
                for file in self.readme_files:
                    if os.path.exists(file):
                        with open(file, 'r', encoding='utf-8') as f:
                            content = f.read()
                            
                        # æå–æ‰€æœ‰é“¾æ¥
                        links = re.findall(r'\[([^\]]+)\]\(([^)]+)\)', content)
                        all_links[file] = []
                        
                        for text, url in links:
                            link_info = {'text': text, 'url': url, 'status': 'unknown'}
                            
                            # æ£€æŸ¥æœ¬åœ°æ–‡ä»¶é“¾æ¥
                            if not url.startswith(('http://', 'https://', '#')):
                                if os.path.exists(url):
                                    link_info['status'] = 'valid'
                                else:
                                    link_info['status'] = 'broken'
                                    broken_links.append(f"{file}: {url}")
                            
                            # HTTPé“¾æ¥æ£€æŸ¥ï¼ˆç®€åŒ–ç‰ˆï¼‰
                            elif url.startswith(('http://', 'https://')):
                                try:
                                    # åªæ£€æŸ¥å‡ ä¸ªå…³é”®é“¾æ¥ï¼Œé¿å…è¿‡å¤šè¯·æ±‚
                                    if any(domain in url for domain in ['github.com', 'pypi.org', 'npmjs.com']):
                                        response = requests.head(url, timeout=10, allow_redirects=True)
                                        link_info['status'] = 'valid' if response.status_code < 400 else 'broken'
                                    else:
                                        link_info['status'] = 'skipped'
                                except:
                                    link_info['status'] = 'error'
                            else:
                                link_info['status'] = 'anchor'
                                
                            all_links[file].append(link_info)
                
                # è®¡ç®—é“¾æ¥å¥åº·åº¦
                total_links = sum(len(links) for links in all_links.values())
                broken_count = len(broken_links)
                link_score = max(0, 100 - (broken_count * 10)) if total_links > 0 else 100
                
                self.results['link_validation'] = {
                    'score': link_score,
                    'total_links': total_links,
                    'broken_links': broken_count,
                    'broken_list': broken_links[:10],  # æœ€å¤šæ˜¾ç¤º10ä¸ª
                    'status': 'PASS' if link_score >= 80 else 'FAIL'
                }
                
                print(f"âœ… é“¾æ¥æœ‰æ•ˆæ€§: {link_score}/100")
                print(f"   æ€»é“¾æ¥æ•°: {total_links}")
                print(f"   æŸåé“¾æ¥: {broken_count}")
                
            def check_translation_sync(self):
                """æ£€æŸ¥ç¿»è¯‘åŒæ­¥æ€§"""
                print("ğŸŒ æ£€æŸ¥ç¿»è¯‘åŒæ­¥æ€§...")
                
                if not all(os.path.exists(f) for f in self.readme_files):
                    print("âš ï¸  ç¼ºå°‘æŸäº›READMEæ–‡ä»¶")
                    self.results['translation_sync'] = {
                        'score': 60,
                        'status': 'WARN',
                        'message': 'ç¼ºå°‘æŸäº›READMEæ–‡ä»¶'
                    }
                    return
                
                # æ£€æŸ¥æ–‡ä»¶ä¿®æ”¹æ—¶é—´
                mod_times = {}
                for file in self.readme_files:
                    mod_times[file] = os.path.getmtime(file)
                    
                # è®¡ç®—æ—¶é—´å·®å¼‚ï¼ˆç§’ï¼‰
                times = list(mod_times.values())
                time_diff = max(times) - min(times)
                
                # æ ¹æ®æ—¶é—´å·®è¯„åˆ†ï¼ˆ7å¤©å†…ä¿®æ”¹è®¤ä¸ºæ˜¯åŒæ­¥çš„ï¼‰
                sync_score = max(0, 100 - (time_diff / (7 * 24 * 3600) * 20))
                
                self.results['translation_sync'] = {
                    'score': int(sync_score),
                    'time_diff_days': round(time_diff / (24 * 3600), 2),
                    'status': 'PASS' if sync_score >= 80 else 'WARN',
                    'mod_times': {f: f"{os.path.getmtime(f):.0f}" for f in self.readme_files}
                }
                
                print(f"âœ… ç¿»è¯‘åŒæ­¥æ€§: {int(sync_score)}/100")
                print(f"   æœ€å¤§æ—¶é—´å·®: {round(time_diff / (24 * 3600), 1)} å¤©")
                
            def generate_report(self):
                """ç”Ÿæˆè´¨é‡æŠ¥å‘Š"""
                print("\nğŸ“Š ç”Ÿæˆè´¨é‡æŠ¥å‘Š...")
                
                # è®¡ç®—æ€»åˆ†
                scores = [
                    self.results['structure_consistency'].get('score', 0),
                    self.results['link_validation'].get('score', 0),
                    self.results['translation_sync'].get('score', 0)
                ]
                overall_score = sum(scores) // len(scores)
                self.results['overall_score'] = overall_score
                
                # ç”ŸæˆGitHub Actionsæ‘˜è¦
                summary = f"""## ğŸ“Š READMEè´¨é‡æ£€æŸ¥æŠ¥å‘Š

### ğŸ† æ€»ä½“è¯„åˆ†: {overall_score}/100

| æ£€æŸ¥é¡¹ç›® | åˆ†æ•° | çŠ¶æ€ | è¯¦æƒ… |
|----------|------|------|------|
| ğŸ“ ç»“æ„ä¸€è‡´æ€§ | {self.results['structure_consistency'].get('score', 0)}/100 | {self.results['structure_consistency'].get('status', 'N/A')} | {len(self.results['structure_consistency'].get('details', {}))} ä¸ªæ–‡ä»¶ |
| ğŸ”— é“¾æ¥æœ‰æ•ˆæ€§ | {self.results['link_validation'].get('score', 0)}/100 | {self.results['link_validation'].get('status', 'N/A')} | {self.results['link_validation'].get('broken_links', 0)} ä¸ªæŸåé“¾æ¥ |
| ğŸŒ ç¿»è¯‘åŒæ­¥æ€§ | {self.results['translation_sync'].get('score', 0)}/100 | {self.results['translation_sync'].get('status', 'N/A')} | {self.results['translation_sync'].get('time_diff_days', 0)} å¤©å·®å¼‚ |

### ğŸ“‹ è¯¦ç»†ä¿¡æ¯

**ç»“æ„ä¸€è‡´æ€§è¯¦æƒ…:**
"""
                
                for file, count in self.results['structure_consistency'].get('details', {}).items():
                    summary += f"\n- `{file}`: {count} ä¸ªæ ‡é¢˜"
                
                if self.results['link_validation'].get('broken_links'):
                    summary += f"\n\n**æŸåé“¾æ¥åˆ—è¡¨:**\n"
                    for link in self.results['link_validation']['broken_list']:
                        summary += f"\n- âŒ {link}"
                
                summary += f"\n\n### ğŸ¯ å»ºè®®\n"
                
                if overall_score >= 90:
                    summary += "âœ… è´¨é‡ä¼˜ç§€ï¼ç»§ç»­ä¿æŒã€‚"
                elif overall_score >= 70:
                    summary += "âš ï¸ è´¨é‡è‰¯å¥½ï¼Œæœ‰æ”¹è¿›ç©ºé—´ã€‚"
                else:
                    summary += "ğŸš¨ éœ€è¦æ”¹è¿›ï¼è¯·æ£€æŸ¥ä¸Šè¿°é—®é¢˜ã€‚"
                
                # å†™å…¥GitHub Actionsæ‘˜è¦
                github_step_summary = os.environ.get('GITHUB_STEP_SUMMARY')
                if github_step_summary:
                    with open(github_step_summary, 'w', encoding='utf-8') as f:
                        f.write(summary)
                
                # ä¿å­˜è¯¦ç»†ç»“æœ
                with open('readme-quality-report.json', 'w', encoding='utf-8') as f:
                    json.dump(self.results, f, indent=2, ensure_ascii=False)
                
                print("âœ… æŠ¥å‘Šå·²ç”Ÿæˆ")
                
                # æ ¹æ®åˆ†æ•°å†³å®šé€€å‡ºç 
                return 0 if overall_score >= 70 else 1
                
            def run_all_checks(self):
                """è¿è¡Œæ‰€æœ‰æ£€æŸ¥"""
                print("ğŸš€ å¼€å§‹READMEè´¨é‡æ£€æŸ¥...\n")
                
                self.check_structure_consistency()
                self.check_link_validation() 
                self.check_translation_sync()
                
                exit_code = self.generate_report()
                
                print(f"\nğŸ¯ æ£€æŸ¥å®Œæˆï¼æ€»åˆ†: {self.results['overall_score']}/100")
                return exit_code

        if __name__ == "__main__":
            checker = READMEQualityChecker()
            exit_code = checker.run_all_checks()
            exit(exit_code)
        EOF
        
    - name: Run README quality check
      run: python readme_checker.py
      
    - name: Upload quality report
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: readme-quality-report
        path: readme-quality-report.json
        retention-days: 30
        
    - name: Comment PR (if applicable)
      if: github.event_name == 'pull_request' && always()
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          if (fs.existsSync('readme-quality-report.json')) {
            const report = JSON.parse(fs.readFileSync('readme-quality-report.json', 'utf8'));
            
            const score = report.overall_score;
            const emoji = score >= 90 ? 'ğŸ†' : score >= 70 ? 'âœ…' : 'âš ï¸';
            
            const comment = `${emoji} **READMEè´¨é‡æ£€æŸ¥ç»“æœ: ${score}/100**
            
ğŸ“ ç»“æ„ä¸€è‡´æ€§: ${report.structure_consistency?.score || 0}/100
ğŸ”— é“¾æ¥æœ‰æ•ˆæ€§: ${report.link_validation?.score || 0}/100  
ğŸŒ ç¿»è¯‘åŒæ­¥æ€§: ${report.translation_sync?.score || 0}/100

æŸ¥çœ‹è¯¦ç»†æŠ¥å‘Šè¯·ç‚¹å‡» Actions æ ‡ç­¾é¡µã€‚`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
          }